# ============================================================================
# WORKFLOW: Infrastructure Deploy
# ============================================================================
#
# PURPOSE:
#   Deploys all AWS infrastructure including the CloudFormation stack,
#   Lambda function (using the JAR from backend-build), API Gateway, and
#   any other AWS resources. This is the single deployment workflow that
#   handles everything in AWS.
#
# TRIGGERS:
#   1. Called by backend-build (workflow_call):
#      - PRIMARY TRIGGER: Only after successful build and unit tests
#      - Automatically triggered when backend-build completes successfully on push events
#      - Inputs: branch_name, jar_artifact_name
#      - Branch name handling:
#        * Push events: Uses the branch that was pushed
#        * Main branch: Deploys to production stack (StrideStack)
#        * Feature branches: Deploys to branch-specific stack
#      - Downloads JAR artifact from backend-build and deploys everything
#      - NOTE: PRs are handled separately by pr-validation.yaml (no deployment)

#   2. Manual trigger (workflow_dispatch):
#      - Can be run manually with branch_name input
#      - Use with caution: bypasses build/test gates
#      - Requires JAR file to be manually placed in aws_resources/backend/build/libs/
#
# WORKFLOW FLOW:
#   workflow_call (from backend-build) OR workflow_dispatch
#       ‚Üì
#   infrastructure-deploy runs
#       ‚Üì
#   [Download JAR artifact from backend-build] ‚Üí [Place JAR in backend/build/libs/]
#       ‚Üì
#   [Check CDK bootstrap] ‚Üí [Bootstrap if needed]
#       ‚Üì
#   [Deploy CDK Stack] ‚Üí [Stack includes Lambda with JAR]
#       ‚Üì
#   [Get Stack Outputs] ‚Üí [Post stack info to PR]
#       ‚Üì
#   [Call integration-tests.yml]
#
# CALLS OTHER WORKFLOWS:
#   - integration-tests.yml (workflow_call)
#     * Condition: Always after successful stack deployment
#     * Purpose: Run integration tests against the newly deployed stack
#     * Inputs: api_endpoint, stack_name, branch_name
#
# OUTPUTS:
#   - Stack name:
#     * Main branch: "StrideStack" (production stack)
#     * Feature branches: "StrideStack-{issue_number}-{<100 char description}" (branch-specific)
#   - API Gateway endpoint URL
#   - Stack status
#   - Deployment timestamp
#
# DEPENDENCIES:
#   - MUST be called by: backend-build.yml (after successful build and tests)
#   - Requires: JAR artifact from backend-build workflow
#   - This workflow ONLY runs automatically after backend-build succeeds
#   - Manual trigger (workflow_dispatch) available for testing/debugging only
#
# ============================================================================

name: Infrastructure Deploy

on:
  workflow_call:
    inputs:
      jar_artifact_name:
        required: true
        type: string
        description: 'Name of the JAR artifact to download'
  
  workflow_dispatch:
    inputs:
      jar_artifact_name:
        required: false
        type: string
        description: 'Name of the JAR artifact to download (optional)'

# Permissions required for OIDC (OpenID Connect) authentication and called workflows
permissions:
  id-token: write  # Required for OIDC to request JWT token
  contents: read   # Required to checkout code
  checks: write    # Required for called workflow (integration-tests) to create check runs
  pull-requests: write  # Required for called workflow (integration-tests) to post PR comments

jobs:
  deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    outputs:
      api_endpoint: ${{ steps.stack-outputs.outputs.api_endpoint }}
      ws_api_endpoint: ${{ steps.stack-outputs.outputs.ws_api_endpoint }}
    
    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4
      

      # Step 2: Download JAR artifact from backend-build workflow
      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.jar_artifact_name || 'kotlin-app-jar' }}
          path: aws_resources/backend/build/libs/
        continue-on-error: true
      
      # Step 3: Verify JAR exists in backend/build/libs/
      - name: Verify JAR exists
        working-directory: aws_resources/backend
        run: |
          if [ ! -f "build/libs/kotlin_app-1.0-all.jar" ]; then
            echo "‚ùå Error: JAR file not found!"
            echo "Expected location: build/libs/kotlin_app-1.0-all.jar"
            exit 1
          fi
          echo "‚úÖ JAR verified:"
          ls -lh build/libs/kotlin_app-1.0-all.jar
      

      # Step 4: Set up Python for CDK
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: aws_resources/requirements.txt
      
      # Step 5: Install Python dependencies
      - name: Install Python dependencies
        working-directory: aws_resources
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Install Schema Initializer dependencies
        working-directory: aws_resources/schema_initializer
        run: |
          pip install -r requirements.txt -t .
      
      # Step 6: Install jq (required for parsing stack outputs)
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      
      # Step 7: Install CDK
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install CDK
        run: npm install -g aws-cdk
      
      # Step 8: Configure AWS credentials
      # Note: Using OIDC role assumption (no long-lived access keys required)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
      
      # Step 9: Check if CDK is bootstrapped
      - name: Check CDK bootstrap
        id: cdk-bootstrap
        run: |
          if aws cloudformation describe-stacks --stack-name CDKToolkit --region us-east-1 2>/dev/null | grep -q "CDKToolkit"; then
            echo "‚úÖ CDK already bootstrapped"
            echo "bootstrapped=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è CDK not bootstrapped, will bootstrap now"
            echo "bootstrapped=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true
      
      # Step 10: Bootstrap CDK if needed
      - name: Bootstrap CDK
        if: steps.cdk-bootstrap.outcome == 'failure' || steps.cdk-bootstrap.outputs.bootstrapped == 'false'
        working-directory: aws_resources
        run: |
          cdk bootstrap aws://${{ secrets.AWS_ACCOUNT_ID }}/us-east-1
      
      # Step 11: Deploy CDK
      - name: Deploy CDK stack
        id: deploy
        working-directory: aws_resources
        env:
          CDK_DEFAULT_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
          CDK_DEFAULT_REGION: us-east-1
        run: |
          if cdk deploy --require-approval never --all --outputs-file cdk-outputs.json; then
            echo "‚úÖ Deployment successful!"
            echo "deployment_status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Deployment failed!"
            echo "deployment_status=failure" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      # Step 12: Get stack outputs and display in Actions UI
      - name: Get stack outputs
        id: stack-outputs
        working-directory: aws_resources
        run: |
          # Get the stack name from the outputs file generated by cdk deploy
          if [ ! -f "cdk-outputs.json" ]; then
            echo "Error: cdk-outputs.json not found"
            exit 1
          fi

          # Get the first (and only) stack identifier from the JSON structure
          STACK_KEY=$(jq -r 'keys[0]' cdk-outputs.json 2>/dev/null || echo "")
          if [ -z "$STACK_KEY" ] || [ "$STACK_KEY" == "null" ]; then
            echo "Error: Could not extract stack key from cdk-outputs.json"
            exit 1
          fi

          # Extract StackName from the outputs
          STACK_NAME=$(jq -r ".\"$STACK_KEY\".StackName // empty" cdk-outputs.json 2>/dev/null || echo "")
          if [ -z "$STACK_NAME" ] || [ "$STACK_NAME" == "null" ]; then
            echo "Error: Could not extract StackName from cdk-outputs.json"
            exit 1
          fi

          # Extract APIEndpointURL from the outputs
          API_ENDPOINT=$(jq -r ".\"$STACK_KEY\".RestAPIEndpointURL // empty" cdk-outputs.json 2>/dev/null || echo "")
          if [ -z "$API_ENDPOINT" ] || [ "$API_ENDPOINT" == "null" ]; then
            echo "Warning: Could not extract APIEndpointURL from cdk-outputs.json"
          fi

          # Extract WebSocket from the outputs
          WS_API_ENDPOINT=$(jq -r ".\"$STACK_KEY\".WebSocketURL // empty" cdk-outputs.json 2>/dev/null || echo "")
          if [ -z "$API_ENDPOINT" ] || [ "$API_ENDPOINT" == "null" ]; then
            echo "Warning: Could not extract WebSocketURL from cdk-outputs.json"
          fi

          echo "stack_name=$STACK_NAME" >> $GITHUB_OUTPUT
          echo "Deployed stack: $STACK_NAME"
          echo "Reading outputs from cdk-outputs.json for stack $STACK_NAME"
          
          # Set outputs for use in subsequent steps or workflow outputs
          if [ -n "$API_ENDPOINT" ]; then
            echo "api_endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT
            echo "‚úÖ REST API Endpoint: $API_ENDPOINT"
          fi

          if [ -n "$WS_API_ENDPOINT" ]; then
            echo "ws_api_endpoint=$WS_API_ENDPOINT" >> $GITHUB_OUTPUT
            echo "‚úÖ WebSocket API Endpoint: $WS_API_ENDPOINT"
          fi
          
          # Create job summary with formatted markdown (shows up in Actions UI summary tab)
          DEPLOY_TIME=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          {
            echo "## üöÄ Deployment Successful"
            echo ""
            echo "### Stack Information"
            echo "- **Stack Name**: \`${STACK_NAME}\`"
            echo "- **Region**: \`us-east-1\`"
            echo "- **Deployed At**: \`${DEPLOY_TIME}\`"
            echo ""
            echo "### Stack Outputs"
            if [ -n "$API_ENDPOINT" ]; then
              echo ""
              echo "#### üåê API Gateway Endpoint"
              echo "- **URL**: [${API_ENDPOINT}](${API_ENDPOINT})"
              echo "- **Test**: \`curl ${API_ENDPOINT}/items\`"
            fi
            if [ -n "$WS_API_ENDPOINT" ]; then
              echo ""
              echo "#### üåê WebSocket Endpoint"
              echo "- **URL**: \`${WS_API_ENDPOINT}\`"
            fi
            echo ""
            echo "<details>"
            echo "<summary>üìã All Stack Outputs</summary>"
            echo ""
            echo "\`\`\`json"
            jq ".\"$STACK_KEY\"" cdk-outputs.json
            echo "\`\`\`"
            echo "</details>"
          } >> $GITHUB_STEP_SUMMARY
          
          # Display all outputs in logs as well
          echo "üìã Stack Outputs:"
          jq ".\"$STACK_KEY\"" cdk-outputs.json
        continue-on-error: true

  integration-tests:
    name: Run Integration Tests
    needs: deploy
    if: success() && needs.deploy.outputs.api_endpoint != ''
    uses: ./.github/workflows/integration-tests.yaml
    with:
      api_endpoint: ${{ needs.deploy.outputs.api_endpoint }}
      ws_api_endpoint: ${{ needs.deploy.outputs.ws_api_endpoint }}
    secrets: inherit
